---
author: [Aidan Dyga, Nicholas Ingerson-Meacham, Ochirsaikhan Davaajambal, Keller Liptrap, Sabrina Rodriguez]
title: A Comparative Analysis of Sorting Algorithms using Doubling Experiments
page-layout: full
categories: [post, containment checking, lists]
date: "2024-02-16"
date-format: long
toc: true
---


# Sorty-Sort Overview

An algorithm analysis tool that utilizes a doubling experiment to predict big O time complexity.

## Use the following commands to run the tool

1. source env/bin/activate
2. python main.py


### Introduction

here

### Running the Tool

how to with source code

### Sorting Algorithms and Output for Each

everyone describe yours here

#### Timsort

describe algorithm

provide output

#### Quicksort

In this implementation of the algorithm, the `quicksort` function serves as a wrapper function to start the sorting process. It calls the `_quicksort` function, passing the list `L`, the leftmost index (`0`), and the rightmost index (`len(L)`).

The `_quicksort` function performs the recursive sorting process. It checks if the sublist has more than one element and, if so, calls the `partition` function to partition the sublist into smaller sublists.

The `partition` function selects a random pivot element within the sublist and places it at the end. Then, it initializes two pointers, `i` and `j`, at the beginning and end of the sublist, respectively. The function then iterates through the sublist, swapping elements to ensure that all elements less than the pivot are on the left side and all elements greater than or equal to the pivot are on the right side. Finally, it places the pivot in its correct location within the sublist and returns its index.

The quicksort algorithm is not the most efficient sorting algorithm we benchmarked, as its worst-case time complexity is *O(n^2)*.

**Benchmark results for `quicksort` using integers:**

```
Original array: [64, 34, 25, 12, 22, 11, 90]
Sorted array using standard bubble sort: [11, 12, 22, 25, 34, 64, 90]

Welcome to your Algorithm Analysis Tool!

File to benchmark (e.g. bubblesort.py): quicksort.py
Type of data to use (int,str): int
Start size of list of data: 1000

Run  1 of 5 for quicksort.py operation with int list using size  1000 took 0.0033570390 seconds and had a doubling ratio of          N/A
Run  2 of 5 for quicksort.py operation with int list using size  2000 took 0.0055074090 seconds and had a doubling ratio of 1.6405555601
Run  3 of 5 for quicksort.py operation with int list using size  4000 took 0.0078437460 seconds and had a doubling ratio of 1.4242170877
Run  4 of 5 for quicksort.py operation with int list using size  8000 took 0.0166555880 seconds and had a doubling ratio of 2.1234226595
Run  5 of 5 for quicksort.py operation with int list using size 16000 took 0.0559699330 seconds and had a doubling ratio of 3.3604297249

Average Doubling Ratio: 2.1371562580375514
Predicted Time Complexity: Quadratic
Memory Usage: 11.12 MB
```

**Benchmark results for `quicksort` using strings:**

```
Original array: [64, 34, 25, 12, 22, 11, 90]
Sorted array using standard bubble sort: [11, 12, 22, 25, 34, 64, 90]

Welcome to your Algorithm Analysis Tool!

File to benchmark (e.g. bubblesort.py): quicksort.py
Type of data to use (int,str): str
Start size of list of data: 1000

Run  1 of 5 for quicksort.py operation with str list using size  1000 took 0.0020752440 seconds and had a doubling ratio of          N/A
Run  2 of 5 for quicksort.py operation with str list using size  2000 took 0.0019696090 seconds and had a doubling ratio of 0.9490975548
Run  3 of 5 for quicksort.py operation with str list using size  4000 took 0.0049886560 seconds and had a doubling ratio of 2.5328153941
Run  4 of 5 for quicksort.py operation with str list using size  8000 took 0.0097829390 seconds and had a doubling ratio of 1.9610370003
Run  5 of 5 for quicksort.py operation with str list using size 16000 took 0.0209633500 seconds and had a doubling ratio of 2.1428478708

Average Doubling Ratio: 1.8964494549936606
Predicted Time Complexity: Quadratic
Memory Usage: 12.50 MB
```

#### Mergesort

describe algorithm

provide output

#### Bubblesort

describe algorithm

provide output

#### Selectionsort

```python
def selection_sort(arr):
   n = len(arr)
   for i in range(n):
       min_index = i
       for j in range(i + 1, n):
           if arr[j] < arr[min_index]:
               min_index = j
       arr[i], arr[min_index] = arr[min_index], arr[i]
```

Selection sorting is a method of sorting values within an array using two sublists that are unsorted and sorted lists. Initially, the sorted list is empty and the unsorted list is the array the function starts with. Based on the implementation of selection sortit will loop through the starting array or the unsorted list with value take the smallest values or the largest value and place it into the sorted sublist. This loop happens until the unsorted list is empty and the sorted list is complete in descending or ascending order of values.  The worst-case time complexity of selection sorting is O(n^2) due to two nested for loops.

| Array Size | Time Taken (seconds) | Doubling Ratio | 
|------------|----------------------|----------------|
| 1000       | 0.028937             | N/A            | 
| 2000       | 0.113565             | 3.92           | 
| 4000       | 0.444057             | 3.91           | 
| 8000       | 1.733939             | 3.90           | 
| 16000      | 6.894565             | 3.98           | 

Overall selection sort was fastest when the array size was 1000 and the slowest when the array size was 16000. The average time taken for the function to run was 1.84 seconds. The doubling ratio was around 3.9 for each of the array sizes. This means that each time the array doubled it would take roughly 4 times as long to sort the array.

### Conclusion

here

### What we could improve?

ideas like ai here
